#!/bin/bash
startDir=`pwd`
scriptName=${0##*/}
if [ $scriptName = $0 ]; then
  scriptPath=$startDir
else
  scriptPath=${0%/$scriptName}
  scriptPath=`cd $scriptPath && pwd`
  cd $startDir
fi
source $scriptPath/color.cfg


# TODO Build in docker only, without use local Node.js

# TODO method zip, npm

if ! [ $1 ] ; then
  echo 'Usage: iondv-app [OPTION]... IONDV_APP_NAME|IONDV_APP_NAME@VERSION|GIT_URL'
  echo 'Install IONDV. Framework application in the current dirrectory and create docker image.'
  echo
  echo 'Options:'
  echo 'Build app method options:'
  echo ' -t [value]                   git: use git clone '
#  echo '                              npm: get from npm [in construction]'
  echo '                              docker:  without specific software in host machine, only docker image (by default)'
  echo  'Universal options'
  echo '  -c [value]                  start cluster with [value] count'
  echo '  -m [value]                  mongo uri, for example: mongodb:27017. localhost:27017 - by default'
  echo '  -r                          remove app workspace folder, if it exists'
  echo '  -i                          data import'
  echo '  -a                          acl (role and user) import'
  echo '  -y                          yes to all'
  echo '  -q                          quiet mode. Show only major information and warnings'
  echo '  -l [value]                  mongodb docker name to link the app with docker container'
  echo '                              (with -d option or docker method)'
  echo '                              also set mongo uri value to [value]:27017'
  echo '  -p [value]                  workspace path, where will be created app folder'
  echo '  -s [value]                  full path to the script, run after installing and before building the app'
  echo '  -n [value]                  new app namespace and name'
  echo '  -h                          skip checkout to version in tag. Use default (last) version'
  echo "  -x                          exit without start app, after build"
  echo 'Options for git, zip, npm method:'
  echo '  -d                          stop, remove runnig app docker container and image,'
  echo '                              build for local deploy (git build method)'
  echo '  -k                          skip environment check'
  echo 'Options for docker method (ci):'
  echo '  -v                          save temporal docker image as a template version, for example registry:3.0.0'
  echo '                              (to create cached version of components'
  echo
  echo 'Environment:'
  echo '  IONDVUrlGitFramework       URL to get framework by default is https://github.com/iondv/framework.git'
  echo '                             You can also set login and password to use it in private repositry, for example'
  echo '                             https://login:password@git.company-name.com/iondv/framework.git'
  echo '  IONDVUrlGitModules         Base of URL to get modules, by default https://github.com/iondv'
  echo '  IONDVUrlGitApp             Base of URL to get app, by default https://github.com/iondv'
  echo '  IONDVUrlGitExtApp          Base of URL to get app extension, by default https://github.com/iondv'

  echo
  echo 'Example:'
  echo '  ./iondv-app --method docker -l mongodb khs-ticket-discount@1.0.1'
  echo '  ./iondv-app -m localhost:27017 https://github.com/akumidv/svyaz-info.git'
  exit
fi

##################################
# Check function                 #
##################################
function f_check_node() {
  local nodeCheck=`node --version`
  if [ $? -ne 0 ]; then
    echo -en "${i_err}Error check node${i_end}"
    exit
  fi
  local nodeVersion=`echo $nodeCheck | grep -Po "^v\d+" |  grep -Po "\d+"`

  if [[ $nodeVersion -lt 8 || $nodeVersion -gt 10  ]]; then
    echo -en "${i_err}Node major version: $nodeVersion is incompatible. Supported node version between 8.x.x and 10.x.x ${i_end}"
    exit
  elif ! [ $quietMode ] ; then echo "Node major version: $nodeVersion";
  fi
  local npmCheck=`npm --version`
  if [ $? -ne 0 ]; then
    echo -en "${i_err}Error check npm ${i_end}"
    exit
  fi
}

function f_check_bash() {
  local bashVer=`bash --version`
  local regexp='^GNU bash, version ([0-9]+)\.'
  if [[ $bashVer =~ $regexp ]] ; then
    if [ ${BASH_REMATCH[1]} -lt 3 ] ; then
      echo -en "${i_err}Bash version less 3. Need 3 or hignter${i_end}"
      exit
      fi
  else
    echo "Bash version isn't checked. Need 3 or higher"
  fi
}

function f_check_git() {
  if ! [ $quietMode ] ; then echo 'Check environment: git, mongo, node, npm, node-gyp, gulp, bower'; fi
    git --version > /dev/null
    if [ $? -ne 0 ]; then
      echo -en "${i_err}Error check git${i_end}"
      exit
  fi
}
function f_check_npm_dep() {
  local npmPackCheck=`npm -g list node-pre-gyp node-gyp gulp bower`
  if [ $? -ne 0 ]; then
    echo -en "${i_err}Error check npm packages list${i_end}"
    exit
  fi
  echo $npmPackCheck | grep 'node-gyp'  > /dev/null
  if [ $? -ne 0 ]; then
    if [ $yesToAll ] ; then
      choice="y"
    else
      read -p "Error check node-gyp. Install (y/n)?" choice
    fi
    case "$choice" in
      y|Y ) npm install -g node-gyp
            if [ $? -ne 0 ]; then exit; fi;;
      n|N ) echo "node-gyp is requered"; exit;;
      * )   echo "invalid"; exit;;
    esac
  fi
  echo $npmPackCheck | grep 'gulp@4.'  > /dev/null
  if [ $? -ne 0 ]; then
    if [ $yesToAll ] ; then
      choice="y"
    else
      read -p "Error check ^gulp@4.0.0. Install (y/n)?" choice
    fi
    case "$choice" in
      y|Y ) npm install -g gulp
            if [ $? -ne 0 ]; then exit; fi;;
      n|N ) echo "^gulp@4.0.0 is requered"; exit;;
      * )   echo "invalid"; exit;;
    esac
  fi
}

function f_check_mongo () {
  if [ $mongoLink ] ; then
    docker exec -it $mongoLink mongo --quiet --eval 'db.runCommand("ping").ok' > /dev/null
    if [ $? -ne 0 ]; then
      echo -en "${i_err}Error check MongoDb docker container: $mongoLink${i_end}"
    else
      checkMongo=`curl --silent $mongodbUri | grep "MongoDB"` > /dev/null
      if [ $? -ne 0 ]; then
        echo -en "${i_err}Error check MongoDb: $mongodbUri${i_end}"
      fi
    fi
 fi
}

####################################
# Version                          #
####################################
function f_get_framework_ver() {
  packagePath=$1
  local IFS_def=$IFS
  if grep -Eq '"engines"\s*:\s*{' $packagePath && ! grep -Eq '"engines"\s*:\s*{[\s\n]*}' $packagePath; then
    engines=`sed -n -r '/"engines":\s+\{/,/\}/{ /"engines":\s+\{/d; /}/d; p; }' $packagePath`
    if ! [ ${#engines[@]} = 0 ] ; then
      if ! [ $quietMode ] ; then echo "Engine list: $engines"; fi
      enginelist="$(echo "$engines" | tr ',' '\n')"
      #`echo $engines | tr -d [:space:] | tr -d '"' | tr ',' '\n'`
      frameworkVer=$(echo ${enginelist[*]} | grep -oE "\"ion\":[[:blank:]]\".*\"[[:blank:]]*" | cat)
      frameworkVer=${frameworkVer%\"*}
      #"
      frameworkVer=${frameworkVer##*\"}
      #for i in ${enginelist[@]}
      #do
      #  IFS=':' tmp=($i)
      #  if [ ${tmp[0]} = "ion" ]; then
      #    frameworkVer="${tmp[1]}"
      #  fi
      #  IFS=$IFS_def
      #done
    fi
  fi
}
function f_get_metadep_ver() {
  appPackagePath=$1
  metaDepPairList=()
  if grep -q '"ionMetaDependencies"\s*:\s*{' $appPackagePath && ! grep -q '"ionMetaDependencies"\s*:\s*{[\s\n]*}' $appPackagePath; then
    local metadepAll=`sed -n -r '/"ionMetaDependencies":\s+\{/,/\}/{ /"ionMetaDependencies":\s+\{/d; /}/d; p; }' $appPackagePath`
    if ! [ $quietMode ] ; then echo -e "Additional apps list:\n$metadepAll"; fi
    if ! [ ${#metadepAll[@]} = 0 ] ; then
      local rawMetaDepPairList="$(echo -n "$metadepAll" | grep --null -oE "\"[[:alnum:]]+\":[[:blank:]]\".*\",*")"
      local oIFS=$IFS
      IFS=','
      rawMetaDepPairList=($rawMetaDepPairList)
      local name
      local ver
      for temp in "${rawMetaDepPairList[@]}"; do
        echo $temp
        temp=$(echo $temp | grep -oE "\"[[:alnum:]]+\":[[:blank:]]\".*\"[[:blank:]]*" | cat)
        name=${temp#*\"}
        name=${name%%\"*}
        #"
        ver=${temp%\"*}
        #"
        ver=${ver##*\"}
        if [[ `curl -L -s -k -w %{http_code} -o /dev/null $IONDVUrlGitExtApp/$name.git` != '200' ]]; then
          echo "Check extra app $name. $IONDVUrlGitExtApp/$name is missing. Skip"
        else
          metaDepPairList+=("$name:$ver")
        fi
      done
    fi
  fi
}
#  if grep -Eq '"ionModulesDependencies"\s*:\s*{' $frameworkPath/package.json && ! grep -Eq '"ionModulesDependencies"\s*:\s*{[\s\n]*}' $frameworkPath/package.json; then
#'
#    modules=`sed -n -r '/"ionModulesDependencies":\s+\{/,/\}/{ /"ionModulesDependencies":\s+\{/d; /}/d; p; }' $frameworkPath/package.json`
function f_get_modulesdep_ver() {
  appPackagePath=$1
  modulesDepPairList=()
  if grep -Eq '"ionModulesDependencies"\s*:\s*{' $appPackagePath && ! grep -Eq '"ionModulesDependencies"\s*:\s*{[\s\n]*}' $appPackagePath; then
    local modulesdepAll=`sed -n -r '/"ionModulesDependencies":\s+\{/,/\}/{ /"ionModulesDependencies":\s+\{/d; /}/d; p; }' $appPackagePath`
    if ! [ $quietMode ] ; then echo -e "Modules list:\n$modulesdepAll"; fi
    if ! [ "${#modulesdepAll[@]}" = 0 ] ; then
      local rawModulesDepPairList="$(echo -n "$modulesdepAll" | grep --null -oE "\"[[:alnum:]]+\":[[:blank:]]\".*\",*")"
      local oIFS=$IFS
      IFS=','
      rawModulesDepPairList=($rawModulesDepPairList)
      IFS=$oIFS
      local name
      local ver
      for temp in "${rawModulesDepPairList[@]}"; do
        temp=$(echo $temp | grep -oE "\"[[:alnum:]]+\":[[:blank:]]\".*\"[[:blank:]]*" | cat)
        name=${temp#*\"}
        name=${name%%\"*}
        #"
        ver=${temp%\"*}
        #"
        ver=${ver##*\"}
        if [[ `curl -L -s -k -w %{http_code} -o /dev/null $IONDVUrlGitModules/$name.git` != '200' ]]; then
          echo "Check module ${name}. $IONDVUrlGitModules/$name is missing. Skip"
        else
          modulesDepPairList+=("$name:$ver")
        fi
      done
    fi
  else
    modulesDepPairList='registry:*'
  fi
}

function f_get_semver {
  #npm versioning compatibility layer
  if [ -n "$1" ] ; then

    local vpat="$1"
    local output_all="$2"
    local explicit_tags="$3"

    if [ -n "$vpat" ] ; then

      local semver_pat
      if [ "$vpat" == "*" ] || [ "$vpat" == "x" ] ; then
        semver_pat='latest'
      elif [ -n "$(echo "$vpat" | grep -oE "\|\|" | cat)" ] ; then
        semver_pat='or'
      elif [ -n "$(echo "$vpat" | grep -oE "\s\-\s" | cat)" ] ; then
        semver_pat='range'
      elif [ -n "$(echo "$vpat" | grep -oE "\s[<>]" | cat)" ] ; then
        semver_pat='comparison range'
        #TODO [<>] matching: check ^1 <3
      elif [ -n "$(echo "$vpat" | grep -oE "[<>]" | cat)" ] ; then
        semver_pat='comparison'
      elif [ -n "$(echo "$vpat" | grep -oE "^[0-9]+\.[0-9]+\.[0-9]+" | cat)" ] ; then
        semver_pat='exact'
      elif [ -n "$(echo "$vpat" | grep -oE "\~[0-9]+\.[0-9]+\.[0-9x]+" | cat)" ] \
       || [ -n "$(echo "$vpat" | grep -oE "[0-9]+\.[0-9]+\.x" | cat)" ] \
       || [ -n "$(echo "$vpat" | grep -oE "\~[0-9]+\.[0-9]+" | cat)" ] \
       || [ -n "$(echo "$vpat" | grep -oE "^[0-9]+\.[0-9]+" | cat)" ] ; then
        semver_pat='minor'
      elif [ -n "$(echo "$vpat" | grep -oE "\^[0-9]+\.[0-9x]+\.[0-9x]+" | cat)" ] \
       || [ -n "$(echo "$vpat" | grep -oE "[0-9]+\.x\.[0-9x]+" | cat)" ] \
       || [ -n "$(echo "$vpat" | grep -oE "[0-9]+\.x" | cat)" ] \
       || [ -n "$(echo "$vpat" | grep -oE "\^[0-9]+\.[0-9x]+" | cat)" ] \
       || [ -n "$(echo "$vpat" | grep -oE "\^[0-9]+" | cat)" ] \
       || [ -n "$(echo "$vpat" | grep -oE "\~[0-9]+" | cat)" ] \
       || [ -n "$(echo "$vpat" | grep -oE "^[0-9]+" | cat)" ] ; then
        semver_pat='major'
      fi

      if [ -n "$semver_pat" ] ; then

        local prefx
        local maj_ver
        local min_ver
        local patch_ver
        local rev

        local any_found
        local ver
        if [ "$output_all" == "true" ] ; then
          ver=()
        fi

        if [ "$semver_pat" == "range" ] || [ "$semver_pat" == "or" ] || [ "$semver_pat" == "comparison range" ] ; then

          local part_left
          local part_right
          if [ "$semver_pat" == "range" ] ; then
            part_left="${vpat%%[[:blank:]]-*}"
            part_right="<=${vpat#*-[[:blank:]]}"
            f_get_semver "$part_right"
            local match_right="$v_get_semver"

            if [ -n "$part_left" ] ; then
              part_left_maj_ver="$part_left"
              part_left_min_ver="$(echo $part_left_maj_ver | grep -oE "^[0-9]+\.[0-9]+" | cat)"
              part_left_min_ver="${part_left_min_ver#*.}"
              part_left_patch_ver="$(echo $part_left_maj_ver | grep -oE "^[0-9]+\.[0-9]+\.[0-9]+" | cat)"
              part_left_patch_ver="${part_left_patch_ver##*.}"
              part_left_maj_ver="$(echo $part_left_maj_ver | grep -oE "^[0-9]+" | cat)"
            fi

            if [ -z "$part_left_maj_ver" ] ; then part_left_maj_ver=0 ; fi
            if [ -z "$part_left_min_ver" ] ; then part_left_min_ver=0 ; fi
            if [ -z "$part_left_patch_ver" ] ; then part_left_patch_ver=0 ; fi
            
            if [ -n "$match_right" ] ; then
              right_maj_ver="$(echo "$match_right" | grep -oE "[0-9]+\.[0-9]+\.[0-9]+")"
              right_min_ver="$(echo $right_maj_ver | grep -oE "^[0-9]+\.[0-9]+" | cat)"
              right_min_ver="${right_min_ver#*.}"
              right_patch_ver="$(echo $right_maj_ver | grep -oE "^[0-9]+\.[0-9]+\.[0-9]+" | cat)"
              right_patch_ver="${right_patch_ver##*.}"
              right_maj_ver="$(echo $right_maj_ver | grep -oE "^[0-9]+" | cat)"
            fi

            if [ -n "$part_left" ] && [ -n "$match_right" ] ; then
              if [ "$right_maj_ver" -gt "$part_left_maj_ver" ] \
               || ( [ "$right_maj_ver" -eq "$part_left_maj_ver" ] && [ "$right_min_ver" -gt "$part_left_min_ver" ] ) \
               || ( [ "$right_maj_ver" -eq "$part_left_maj_ver" ] && [ "$right_min_ver" -eq "$part_left_min_ver" ] && [ "$right_patch_ver" -ge "$part_left_patch_ver" ] ) ; then
                any_found='true'
                ver="$match_right"
              fi
            fi

          elif [ "$semver_pat" == "comparison range" ] ; then
            part_left="${vpat%%[[:blank:]]*}"
            part_right="${vpat#*[[:blank:]]}"

            f_get_semver "$part_left" true
            local match_left="${v_get_semver[*]}"
            if [ -n "${match_left[*]}" ] ; then
              f_get_semver "$part_right" 'false' "${match_left[@]}"
              local match_right="$v_get_semver"
              if [ -n "$match_right" ] ; then
                ver="$match_right"
                any_found='true'
              fi
            fi

          else
            part_left="${vpat%%[[:blank:]]\|\|*}"
            part_right="${vpat#*\|\|[[:blank:]]}"
            f_get_semver "$part_left"
            local match_left="$v_get_semver"
            if [ -n "$match_left" ] ; then
              any_found='true'
              ver="$match_left"
            else
              f_get_semver "$part_right"
              local match_right="$v_get_semver"
              any_found='true'
              ver="$match_right"
            fi
          fi

          if [ "$any_found" == "true" ] ; then
            v_get_semver="$ver"
            v_pat_get_semver="$semver_pat"
            return 0
          else
            v_get_semver=''
            v_pat_get_semver=''
            return 1
          fi
          exit
        fi

        if [ "$semver_pat" == "comparison" ] ; then
          if [ -n "$(echo "$vpat" | grep -oE "<=" | cat)" ] ; then
            semver_pat="less_equal"
          elif [ -n "$(echo "$vpat" | grep -oE ">=" | cat)" ] ; then
            semver_pat="greater_equal"
          elif [ -n "$(echo "$vpat" | grep -oE "<" | cat)" ] ; then
            semver_pat="less"
          else
            semver_pat="greater"
          fi
        fi

        local avail_tags
        if [ -z "${explicit_tags[@]}" ] ; then
          avail_tags="$(git tag -l)"
        else
          avail_tags="${explicit_tags[@]}"
        fi

        local upto_maj
        local upto_min
        local upto_patch

        if [ "$semver_pat" == "major" ] ; then
          if [ -n "$(echo $vpat | grep -oE "\^" | cat)" ] ; then
            maj_ver="${vpat#*^}"
            min_ver="$(echo $maj_ver | grep -oE "^[0-9]+\.[0-9]+" | cat)"
            min_ver="${min_ver#*.}"
            patch_ver="$(echo $maj_ver | grep -oE "^[0-9]+\.[0-9]+\.[0-9]+" | cat)"
            patch_ver="${patch_ver##*.}"
            maj_ver="$(echo $maj_ver | grep -oE "^[0-9]+" | cat)"
          elif [ -n "$(echo $vpat | grep -oE "\~" | cat)" ] ; then
            #for compatibility reasons
            maj_ver="${vpat#*~}"
            min_ver="$(echo $maj_ver | grep -oE "^[0-9]+\.[0-9]+" | cat)"
            min_ver="${min_ver#*.}"
            patch_ver="$(echo $maj_ver | grep -oE "^[0-9]+\.[0-9]+\.[0-9]+" | cat)"
            patch_ver="${patch_ver##*.}"
            maj_ver="$(echo $maj_ver | grep -oE "^[0-9]+" | cat)"
          else
            maj_ver="$vpat"
            min_ver="$(echo $maj_ver | grep -oE "^[0-9]+\.[0-9]+" | cat)"
            min_ver="${min_ver#*.}"
            patch_ver="$(echo $maj_ver | grep -oE "^[0-9]+\.[0-9]+\.[0-9]+" | cat)"
            patch_ver="${patch_ver##*.}"
            maj_ver="$(echo $maj_ver | grep -oE "^[0-9]+" | cat)"
          fi

        elif [ "$semver_pat" == "minor" ] ; then
          if [ -n "$(echo $vpat | grep -oE "\~" | cat)" ] ; then
            maj_ver="${vpat#*~}"
            min_ver="$(echo $maj_ver | grep -oE "^[0-9]+\.[0-9]+" | cat)"
            min_ver="${min_ver#*.}"
            patch_ver="$(echo $maj_ver | grep -oE "^[0-9]+\.[0-9]+\.[0-9]+" | cat)"
            patch_ver="${patch_ver##*.}"
            maj_ver="$(echo $maj_ver | grep -oE "^[0-9]+" | cat)"
          else
            maj_ver="$vpat"
            min_ver="$(echo $maj_ver | grep -oE "^[0-9]+\.[0-9]+" | cat)"
            min_ver="${min_ver#*.}"
            patch_ver="$(echo $maj_ver | grep -oE "^[0-9]+\.[0-9]+\.[0-9]+" | cat)"
            patch_ver="${patch_ver##*.}"
            maj_ver="$(echo $maj_ver | grep -oE "^[0-9]+" | cat)"
          fi

        elif [ "$semver_pat" == "greater" ] \
         || [ "$semver_pat" == "greater_equal" ] ; then
          if [ "$semver_pat" == "greater_equal" ] ; then
            maj_ver="${vpat#*>=}"
          else
            maj_ver="${vpat#*>}"
          fi
          min_ver="$(echo $maj_ver | grep -oE "^[0-9]+\.[0-9]+" | cat)"
          min_ver="${min_ver#*.}"
          patch_ver="$(echo $maj_ver | grep -oE "^[0-9]+\.[0-9]+\.[0-9]+" | cat)"
          patch_ver="${patch_ver##*.}"
          maj_ver="$(echo $maj_ver | grep -oE "^[0-9]+" | cat)"

        elif [ "$semver_pat" == "less" ] \
         || [ "$semver_pat" == "less_equal" ] ; then
          if [ "$semver_pat" == "less_equal" ] ; then
            upto_maj="${vpat#*<=}"
          else
            upto_maj="${vpat#*<}"
          fi
          upto_min="$(echo $upto_maj | grep -oE "^[0-9]+\.[0-9]+" | cat)"
          upto_min="${upto_min#*.}"
          upto_patch="$(echo $upto_maj | grep -oE "^[0-9]+\.[0-9]+\.[0-9]+" | cat)"
          upto_patch="${upto_patch##*.}"
          upto_maj="$(echo $upto_maj | grep -oE "^[0-9]+" | cat)"

        elif [ "$semver_pat" == "exact" ] ; then
          maj_ver="$vpat"
          min_ver="$(echo $maj_ver | grep -oE "^[0-9]+\.[0-9]+" | cat)"
          min_ver="${min_ver#*.}"
          patch_ver="$(echo $maj_ver | grep -oE "^[0-9]+\.[0-9]+\.[0-9]+" | cat)"
          patch_ver="${patch_ver##*.}"
          maj_ver="$(echo $maj_ver | grep -oE "^[0-9]+" | cat)"
        fi

        if [ -z "$maj_ver" ] ; then maj_ver=0 ; fi
        if [ -z "$min_ver" ] ; then min_ver=0 ; fi
        if [ -z "$patch_ver" ] ; then patch_ver=0 ; fi

        for i in $avail_tags ; do
          local tver
          tver=$(echo $i | grep -oE "[0-9]+\.[0-9]+\.[0-9]+" | cat)

          local tprefx=${i%$tver*}
          local trev=${i#*$tver}
          local tmaj_ver=${tver%%.*}
          local tmin_ver=${tver#*.}
          local tmin_ver=${tmin_ver%.*}
          local tpatch_ver=${tver##*.}

          if [ "$semver_pat" == "latest" ] ; then
            if [ "$tmaj_ver" -gt "$maj_ver" ] \
             || ( [ "$tmaj_ver" -eq "$maj_ver" ] && [ "$tmin_ver" -gt "$min_ver" ] ) \
             || ( [ "$tmaj_ver" -eq "$maj_ver" ] && [ "$tmin_ver" -eq "$min_ver" ] && [ "$tpatch_ver" -gt "$patch_ver" ] ) ; then

              if [ "$output_all" == 'true' ] ; then
                ver+=("${tprefx}${tmaj_ver}.${tmin_ver}.${tpatch_ver}${trev}")
              else
                prefx=$tprefx
                maj_ver=$tmaj_ver
                min_ver=$tmin_ver
                patch_ver=$tpatch_ver
                rev=$trev
              fi

              any_found='true'
            fi

          elif [ "$semver_pat" == "major" ] ; then
            if ( [ "$tmaj_ver" -eq "$maj_ver" ] && [ "$tmin_ver" -ge "$min_ver" ] ) \
             || ( [ "$tmaj_ver" -eq "$maj_ver" ] && [ "$tmin_ver" -eq "$min_ver" ] && [ "$tpatch_ver" -ge "$patch_ver" ] ) ; then

              if [ "$output_all" == 'true' ] ; then
                ver+=("${tprefx}${tmaj_ver}.${tmin_ver}.${tpatch_ver}${trev}")
              else
                prefx=$tprefx
                maj_ver=$tmaj_ver
                min_ver=$tmin_ver
                patch_ver=$tpatch_ver
                rev=$trev
              fi

              any_found='true'
            fi

          elif [ "$semver_pat" == "minor" ] ; then
             if ( [ "$tmaj_ver" -eq "$maj_ver" ] && [ "$tmin_ver" -eq "$min_ver" ] && [ "$tpatch_ver" -ge "$patch_ver" ] ) ; then

              if [ "$output_all" == 'true' ] ; then
                ver+=("${tprefx}${tmaj_ver}.${tmin_ver}.${tpatch_ver}${trev}")
              else
                prefx=$tprefx
                maj_ver=$tmaj_ver
                min_ver=$tmin_ver
                patch_ver=$tpatch_ver
                rev=$trev
              fi

              any_found='true'
            fi

          elif [ "$semver_pat" == "greater_equal" ] ; then
            if [ "$tmaj_ver" -gt "$maj_ver" ] \
             || ( [ "$tmaj_ver" -eq "$maj_ver" ] && [ "$tmin_ver" -gt "$min_ver" ] ) \
             || ( [ "$tmaj_ver" -eq "$maj_ver" ] && [ "$tmin_ver" -eq "$min_ver" ] && [ "$tpatch_ver" -ge "$patch_ver" ] ) ; then

              if [ "$output_all" == 'true' ] ; then
                ver+=("${tprefx}${tmaj_ver}.${tmin_ver}.${tpatch_ver}${trev}")
              else
                prefx=$tprefx
                maj_ver=$tmaj_ver
                min_ver=$tmin_ver
                patch_ver=$tpatch_ver
                rev=$trev
              fi

              any_found='true'
            fi

          elif [ "$semver_pat" == "greater" ] ; then
            if [ "$tmaj_ver" -gt "$maj_ver" ] \
             || ( [ "$tmaj_ver" -eq "$maj_ver" ] && [ "$tmin_ver" -gt "$min_ver" ] ) \
             || ( [ "$tmaj_ver" -eq "$maj_ver" ] && [ "$tmin_ver" -eq "$min_ver" ] && [ "$tpatch_ver" -gt "$patch_ver" ] ) ; then

              if [ "$output_all" == 'true' ] ; then
                ver+=("${tprefx}${tmaj_ver}.${tmin_ver}.${tpatch_ver}${trev}")
              else
                prefx=$tprefx
                maj_ver=$tmaj_ver
                min_ver=$tmin_ver
                patch_ver=$tpatch_ver
                rev=$trev
              fi

              any_found='true'
            fi

          elif [ "$semver_pat" == "less_equal" ] ; then
            if ( [ -n "$upto_maj" ] && [ "$tmaj_ver" -gt "$maj_ver" ] && [ "$tmaj_ver" -lt "$upto_maj" ] ) \
             || ( [ -n "$upto_maj" ] && [ -n "$upto_min" ] && [ "$tmaj_ver" -gt "$maj_ver" ] && [ "$tmaj_ver" -le "$upto_maj" ] && [ "$tmin_ver" -lt "$upto_min" ] ) \
             || ( [ -n "$upto_maj" ] && [ -n "$upto_min" ] && [ -n "$upto_patch" ] && [ "$tmaj_ver" -gt "$maj_ver" ] && [ "$tmaj_ver" -le "$upto_maj" ] && [ "$tmin_ver" -le "$upto_min" ] && [ "$tpatch_ver" -le "$upto_patch" ] ) \
             || ( [ -n "$upto_min" ] && [ "$tmaj_ver" -eq "$maj_ver" ] && [ "$tmin_ver" -gt "$min_ver" ] && [ "$tmin_ver" -lt "$upto_min" ] ) \
             || ( [ -n "$upto_min" ] && [ -n "$upto_patch" ] && [ "$tmaj_ver" -eq "$maj_ver" ] && [ "$tmin_ver" -gt "$min_ver" ] && [ "$tmin_ver" -le "$upto_min" ] && [ "$tpatch_ver" -le "$upto_patch" ] ) \
             || ( [ -n "$upto_patch" ] && [ "$tmaj_ver" -eq "$maj_ver" ] && [ "$tmin_ver" -eq "$min_ver" ] && [ "$tpatch_ver" -ge "$patch_ver" ] && [ "$tpatch_ver" -le "$upto_patch" ] ) ; then

              if [ "$output_all" == 'true' ] ; then
                ver+=("${tprefx}${tmaj_ver}.${tmin_ver}.${tpatch_ver}${trev}")
              else
                prefx=$tprefx
                maj_ver=$tmaj_ver
                min_ver=$tmin_ver
                patch_ver=$tpatch_ver
                rev=$trev
              fi

              any_found='true'
            fi

          elif [ "$semver_pat" == "less" ] ; then
            if ( [ -n "$upto_maj" ] && [ "$tmaj_ver" -gt "$maj_ver" ] && [ "$tmaj_ver" -lt "$upto_maj" ] ) \
             || ( [ -n "$upto_maj" ] && [ -n "$upto_min" ] && [ "$tmaj_ver" -gt "$maj_ver" ] && [ "$tmaj_ver" -le "$upto_maj" ] && [ "$tmin_ver" -lt "$upto_min" ] ) \
             || ( [ -n "$upto_maj" ] && [ -n "$upto_min" ] && [ -n "$upto_patch" ] && [ "$tmaj_ver" -gt "$maj_ver" ] && [ "$tmaj_ver" -le "$upto_maj" ] && [ "$tmin_ver" -le "$upto_min" ] && [ "$tpatch_ver" -lt "$upto_patch" ] ) \
             || ( [ -n "$upto_min" ] && [ "$tmaj_ver" -eq "$maj_ver" ] && [ "$tmin_ver" -gt "$min_ver" ] && [ "$tmin_ver" -lt "$upto_min" ] ) \
             || ( [ -n "$upto_min" ] && [ -n "$upto_patch" ] && [ "$tmaj_ver" -eq "$maj_ver" ] && [ "$tmin_ver" -gt "$min_ver" ] && [ "$tmin_ver" -le "$upto_min" ] && [ "$tpatch_ver" -lt "$upto_patch" ] ) \
             || ( [ -n "$upto_patch" ] && [ "$tmaj_ver" -eq "$maj_ver" ] && [ "$tmin_ver" -eq "$min_ver" ] && [ "$tpatch_ver" -ge "$patch_ver" ] && [ "$tpatch_ver" -lt "$upto_patch" ] ) ; then

              if [ "$output_all" == 'true' ] ; then
                ver+=("${tprefx}${tmaj_ver}.${tmin_ver}.${tpatch_ver}${trev}")
              else
                prefx=$tprefx
                maj_ver=$tmaj_ver
                min_ver=$tmin_ver
                patch_ver=$tpatch_ver
                rev=$trev
              fi

              any_found='true'
            fi

          elif [ "$semver_pat" == "exact" ] ; then
             if ( [ "$tmaj_ver" -eq "$maj_ver" ] && [ "$tmin_ver" -eq "$min_ver" ] && [ "$tpatch_ver" -eq "$patch_ver" ] ) ; then

              if [ "$output_all" == 'true' ] ; then
                ver+=("${tprefx}${tmaj_ver}.${tmin_ver}.${tpatch_ver}.${trev}")
              else
                prefx=$tprefx
                maj_ver=$tmaj_ver
                min_ver=$tmin_ver
                patch_ver=$tpatch_ver
                rev=$trev
              fi

              any_found='true'
              break
            fi
          fi

        done

        if [ "$any_found" == "true" ] ; then
          if [ "$output_all" == 'true' ] ; then
            v_get_semver="${ver[@]}"
          else
            ver="${prefx}${maj_ver}.${min_ver}.${patch_ver}${rev}"
            v_get_semver="$ver"
          fi
          return 0
        else
          v_get_semver=''
          return 1
        fi
      fi
    fi

  fi
}

function f_switch_branch {
  local gitFolder=$1
  cd $gitFolder || return 1
  if [ -n "$gitBranch" ] ; then
    git checkout $gitBranch > /dev/null 2>&1
    if [ $? -eq 0 ] ; then
      echo "checked out $gitBranch on $gitFolder"
      return 0
    fi
  fi
  if [ -n "$fallbackBranch" ] ; then
    git checkout $fallbackBranch > /dev/null 2>&1
    if [ $? -eq 0 ] ; then
      echo "checked out $fallbackBranch on $gitFolder"
      return 0
    fi
  fi
  if [ -n "$2" ] ; then
    local vtag="${2#tags/}"

    #semantic versioning

    local ver
    f_get_semver "$vtag"
    ver="$v_get_semver"
    if [ -n "$ver" ] ; then
      git checkout "tags/$ver" > /dev/null 2>&1
      if [ $? -eq 0 ] ; then
        echo "checked out tags/$ver on $gitFolder"
      fi
      return 0
    else

      #explicit versioning

      git checkout $2 > /dev/null 2>&1
      if [ $? -eq 0 ] ; then
        echo "checked out $2 on $gitFolder"
      fi
    fi
  fi
  return 0
}

function f_save_package_to_host () {
  docker run --rm --entrypoint="" "$1" cat "$2/package.json" > "$3"
}

##################################
# Build docker                   #
##################################

function f_git_set_dockerfile() {
  local gitDockerName=${1%:*}
  local gitDockerVer=${1##*:}
  local destPath=$2

  if [ -n "$3" ]; then
    if [ ${3##*.} = "git" ]; then local gitUrl=$3; else local gitUrl="$3/$gitDockerName.git"; fi
    if [[ `curl -L -s -k -w %{http_code} -o /dev/null $gitUrl` != '200' ]]; then
      echo "$gitUrl check error"
      exit
    fi
    if ! [ $quietMode ] ; then echo "Build git dockerfile $gitDockerName:$gitDockerVer from $gitUrl"; fi
  fi

  if [ "$2" != "/var" ]; then # Для провки что не фреймворк, для фреймворка подменяем на www
    local folderName=$gitDockerName;
  else
    local folderName='www';
  fi
  if [ $dockerVersionSave ]; then
    local postfix="-git-$gitDockerName"
    echo -e "\nFROM alpine/git as iondv-git-$gitDockerName"                                        > "$frameworkPath/Dockerfile$postfix"
  else
    local postfix=""
    echo -e "\nFROM alpine/git as iondv-git-$gitDockerName"                                        >> "$frameworkPath/Dockerfile$postfix"
  fi
  echo "WORKDIR $destPath"                                                                    >> "$frameworkPath/Dockerfile$postfix"
  if ! [ $skipTagMode ] ; then
    echo "LABEL version=\"$gitDockerVer\""                                                    >> "$frameworkPath/Dockerfile$postfix"
  fi
  if [ -n "$gitUrl" ]; then
    echo "RUN git clone --quiet \"$gitUrl\" $folderName"                                        >> "$frameworkPath/Dockerfile$postfix"
  elif [ -n "$zipPath" ]; then
     mkdir "$frameworkPath/$folderName-zip/"
     unzip -q $zipPath -d "$frameworkPath/$folderName-zip/"
     unzipName=`ls -1p $frameworkPath/$folderName-zip | grep '/$' | sed 's/\/$//' | grep  $folderName` # If zip from github - it have branch on folder name
     if [ -z $unzipName ]; then echo "$zipPath don't have a folder with name $folderName. Exit"; exit; fi
     echo "Unpack name $unzipName, app name: $folderName"
     if [ "$unzipName" != "$folderName" ]; then
       echo -en "${i_warn}Folder $unzipName not equal to $folderName. Include branch name? Rename to $folderName${i_end}"
       mv "$frameworkPath/$folderName-zip/$unzipName" "$frameworkPath/$folderName-zip/$folderName"
     fi
     echo "COPY ./$folderName-zip/$folderName/ $destPath/$folderName/"                                             >> "$frameworkPath/Dockerfile$postfix"
  elif [ -n "$folderPath" ]; then
     mkdir "$frameworkPath/$folderName-folder/"
     cp -r $folderPath $frameworkPath/$folderName-folder/$folderName
     echo "COPY ./$folderName-folder/$folderName/ $destPath/$folderName/"                                            >> "$frameworkPath/Dockerfile$postfix"
  else
    echo -en "${i_err}Not found app source. Exit${i_end}"
    exit
  fi
  echo "COPY ./.dockerignore $destPath/$folderName/.dockerignore"                                          >> "$frameworkPath/Dockerfile$postfix"

  if ! [ $skipTagMode ] && ! [ "$gitDockerVer"="latest" ] ; then
    echo $gitDockerVer
    echo "WORKDIR $destPath/$folderName"                                                    >> "$frameworkPath/Dockerfile$postfix"
    echo "RUN git checkout \"tags/$gitDockerVer\""                                          >> "$frameworkPath/Dockerfile$postfix"
  fi
}


f_check_readiness_docker() {
  echo "Check image $1: " && docker images | grep "${1%:*}\s*${1##*:}\s"
  return $?
}

#  f_buld_docker_version $1 - image Name; $2 - path to Dockerfile $3 - path to build; $4 - ignore current image
function f_buld_docker_version() {
  f_check_readiness_docker "$1"
  local check_res=$?
  if ! [ -z $4 ] ; then
    if [ $check_res -eq 0 ]; then echo -n "  Remove image:           ";  docker rmi $1; fi
    docker image build -t "$1" -f "$2" "$3"
  else
     if [ $check_res -eq 0 ]; then
       echo -en "${i_warn}Docker $1 is exist, skip building${i_end}"; return;
     else
# TODO Didn't cache param. Check?
# --rm --compress --no-cache=true --pull --force-rm
# RM .git?
        docker image build -t "$1" -f "$2" "$3"
        if [ $? -ne 0 ]; then echo -en "${i_err}Error when build docker image $1.  Exit ${i_end}"; exit; fi
    fi
  fi
  # TODO GET VERSION AND COPY AND SET IN NEW ONE DOCKER - SMALLEST AND VERIFED VERSION
  # TODO check rezult version from package.json, after build docker (copy to host) and set it in new docker, when will build by copy from git vesion?
}

##################################
# Create ini and build files      #
##################################
function f_create_setup_ini() {
  configPath="$1"
  echo "auth.denyTop=false"                                                                   > "$frameworkPath$configPath/setup.ini"
  echo "auth.registration=false"                                                              >> "$frameworkPath$configPath/setup.ini"
  echo "db.uri=mongodb://$mongodbUri/$appName"                                                >> "$frameworkPath$configPath/setup.ini"
  echo "server.ports[]=8888"                                                                  >> "$frameworkPath$configPath/setup.ini"
  echo "module.default=registry"                                                              >> "$frameworkPath$configPath/setup.ini"
  echo "fs.storageRoot=./files"                                                               >> "$frameworkPath$configPath/setup.ini"
  echo "fs.urlBase=/files"                                                                    >> "$frameworkPath$configPath/setup.ini"
  echo "deploy.mode=db"                                                                       >> "$frameworkPath$configPath/setup.ini"
  echo "auth.exclude[]=/files/**"                                                             >> "$frameworkPath$configPath/setup.ini"
  echo "auth.exclude[]=/vendor/**"                                                            >> "$frameworkPath$configPath/setup.ini"
  echo "auth.exclude[]=/css/**"                                                               >> "$frameworkPath$configPath/setup.ini"
  echo "auth.exclude[]=/fonts/**"                                                             >> "$frameworkPath$configPath/setup.ini"
  echo "auth.exclude[]=/favicon.ico"                                                          >> "$frameworkPath$configPath/setup.ini"
  for temp in ${modulesDepPairList[@]}; do
    echo "auth.exclude[]=/${temp%:*}/vendor/**"                                               >> "$frameworkPath$configPath/setup.ini"
    echo "auth.exclude[]=/${temp%:*}/css/**"                                                  >> "$frameworkPath$configPath/setup.ini"
    echo "auth.exclude[]=/${temp%:*}/js/**"                                                   >> "$frameworkPath$configPath/setup.ini"
    echo "auth.exclude[]=/${temp%:*}/img/**"                                                  >> "$frameworkPath$configPath/setup.ini"
    echo "auth.exclude[]=/${temp%:*}/fonts/**"                                                >> "$frameworkPath$configPath/setup.ini"
  done
}

function f_create_init_sh() {
  echo "node bin/import --src ./applications/$appName --ns $appName"                          > "$frameworkPath/init.sh"
  echo "node bin/setup $appName --reset"                                                      >> "$frameworkPath/init.sh"
  for temp in ${metaDepPairList[@]}; do
    echo "node bin/setup ${temp%:*}"                                                          >> "$frameworkPath/init.sh"
  done
  if [ $importData ] ; then echo "node bin/import-data --src ./applications/$appName/data --ns $appName" >> "$frameworkPath/init.sh"; fi
  echo "node bin/adduser --name demo --pwd ion-demo"                                          >> "$frameworkPath/init.sh"
  echo "node bin/acl --u demo@local --role admin --p full"                                    >> "$frameworkPath/init.sh"
  if [ $importAcl ] ; then echo "node bin/acl --d ./applications/$appName/acl"                >> "$frameworkPath/init.sh"; fi
  if [ $startCluster ] ; then
    echo "export WORKER_COUNT=$startCluster"                                                  >> "$frameworkPath/init.sh"
    echo "export NODE_ENV=production"                                                        >> "$frameworkPath/init.sh"
    echo "exec node bin/cluster"                                                                   >> "$frameworkPath/init.sh"
  else
    echo "exec node bin/www"                                                                       >> "$frameworkPath/init.sh"
  fi
}

function  f_dockerignore() {
  echo -e "**/.eslintrc.yml"                                                                     > "$frameworkPath/.dockerignore"
  echo -e ".eslinignore\n.editorconfig\n.tern-project"                                           >> "$frameworkPath/.dockerignore"
  echo -e ".gitignore\n**/.git/"                                                                 >> "$frameworkPath/.dockerignore"
  echo -e ".npmignore\n**/package-lock.json"                                                     >> "$frameworkPath/.dockerignore"
  echo -e "/config/config.json.devel\n/config/config.json.prod\n/config/setup.ini.example"       >> "$frameworkPath/.dockerignore"
  echo -e "/docs/**\n**/docs/**\n/changelog*"                                                    >> "$frameworkPath/.dockerignore"
  echo -e "/log/**\n/test/**"                                                                    >> "$frameworkPath/.dockerignore"
  echo -e "/view/default/vendor"                                                                 >> "$frameworkPath/.dockerignore"
  echo -e "/view/default/node_modules"                                                           >> "$frameworkPath/.dockerignore"
  echo -e "/modules/*/view/default/vendor/**"                                                    >> "$frameworkPath/.dockerignore"
  echo -e "/modules/*/view/default/node_modules/**"                                              >> "$frameworkPath/.dockerignore"
  echo -e "/applications/*/themes/*/vendor/**"                                                   >> "$frameworkPath/.dockerignore"
  echo -e "/applications/*/themes/*/node_modules/**"                                             >> "$frameworkPath/.dockerignore"
  echo -e "./Dockerfile"                                                                         >> "$frameworkPath/.dockerignore"
}


function f_build_docker() {
  # Create a docker ROM alpine/git file as iondv-develop-and-test with the application folder
  f_git_set_dockerfile "$appName:$imageVersion" "/var/www/applications" $appGitLink

  if [ $newAppName ] ; then
    cp $scriptPath/change-namespace.sh $frameworkPath/change-namespace.sh
    if [ $dockerVersionSave ]; then # Assembly it all in one Dockerfile.
      echo "COPY ./change-namespace.sh /var/www/applications/change-namespace.sh"               >> "$frameworkPath/Dockerfile-git-$appName"
      echo "RUN sh /var/www/applications/change-namespace.sh $quietMode /var/www/applications/$appName $prevAppName $newAppName" \
                                                                                                >> "$frameworkPath/Dockerfile-git-$appName"
      echo "RUN rm -f /var/www/applications/change-namespace.sh"                                >> "$frameworkPath/Dockerfile-git-$appName"
    else
      echo "COPY ./change-namespace.sh /var/www/applications/change-namespace.sh"               >> "$frameworkPath/Dockerfile"
      echo "RUN sh /var/www/applications/change-namespace.sh $quietMode /var/www/applications/$appName $prevAppName $newAppName" \
                                                                                                >> "$frameworkPath/Dockerfile"
      echo "RUN rm -f /var/www/applications/change-namespace.sh"                                >> "$frameworkPath/Dockerfile"
    fi
  fi
  if [ $imageVersion = 'latest' ];then forceBuildDocker="--check-ignore"; else forceBuildDocker=""; fi

  if [ $dockerVersionSave ]; then # TODO  The problem is that if the version is cached, for example, latest, then the new one will not pull anything up. For latest forcibly
      f_buld_docker_version "iondv-git-$appName:$imageVersion" "$frameworkPath/Dockerfile-git-$appName" "$frameworkPath/." $forceBuildDocker
  else
      f_buld_docker_version "iondv-git-$appName:$imageVersion" "$frameworkPath/Dockerfile" "$frameworkPath/." $forceBuildDocker
  fi
  f_save_package_to_host "iondv-git-$appName:$imageVersion" "/var/www/applications/$appName" "$frameworkPath/package-$appName.json"

  # Build framework docker image
  f_get_framework_ver $frameworkPath/package-$appName.json
  if ! [ $frameworkVer ]; then frameworkVer="latest"; forceBuildDocker="--check-ignore"; else forceBuildDocker=""; fi
  f_git_set_dockerfile "framework:$frameworkVer" "/var" $IONDVUrlGitFramework
  if [ $dockerVersionSave ]; then f_buld_docker_version "iondv-git-framework:$frameworkVer" "$frameworkPath/Dockerfile-git-framework" "$frameworkPath/." $forceBuildDocker; fi

  # ionMetaDependencies
  f_get_metadep_ver $frameworkPath/package-$appName.json
  for temp in ${metaDepPairList[@]}; do
    f_git_set_dockerfile $temp "/var/www/applications" $IONDVUrlGitExtApp
    if [ $dockerVersionSave ]; then f_buld_docker_version "iondv-git-$temp" "$frameworkPath/Dockerfile-git-${temp%:*}" "$frameworkPath/."; fi
  done

  # ionModulesDependencies
  f_get_modulesdep_ver $frameworkPath/package-$appName.json
  for temp in ${modulesDepPairList[@]}; do
    f_git_set_dockerfile $temp "/var/www/modules" $IONDVUrlGitModules
    if [ $dockerVersionSave ]; then f_buld_docker_version "iondv-git-$temp" "$frameworkPath/Dockerfile-git-${temp%:*}" "$frameworkPath/."; fi
  done

  f_create_setup_ini
  f_create_init_sh

  if ! f_check_readiness_docker "$imageName"; then # TODO check - since it is erase files
    if [ $dockerVersionSave ]; then
      echo "FROM node:10 as iondv-base-$appName"                                                >  "$frameworkPath/Dockerfile"
    else
      echo "FROM node:10 as iondv-base-$appName"                                                >>  "$frameworkPath/Dockerfile"
    fi

# TODO DIDN'T WORk. PYTHON NEED for node-gyp, git for bower, vips for sharp http://sharp.pixelplumbing.com/en/stable/install/ - plus 380Mb
# Different size is 400M
# Error in compyle and after start
#    echo "FROM node:10-alpine as iondv-base-$appName"                                         >  "$frameworkPath/Dockerfile"
#    echo "RUN  apk add --no-cache python make g++ \
#         && apk --update add git less openssh && \
#         && apk add vips-dev fftw-dev build-base \
#            --update-cache \
#            --repository https://alpine.global.ssl.fastly.net/alpine/edge/community \
#            --repository https://alpine.global.ssl.fastly.net/alpine/edge/main \
#
#    rm -rf /var/lib/apt/lists/* && \
#    rm -fR /var/cache/apk/*"                                                                  >> "$frameworkPath/Dockerfile"
    echo "WORKDIR /var/www"                                                                   >> "$frameworkPath/Dockerfile"
    if ! [ $skipTagMode ] ; then
      echo "LABEL version=\"$imageVersion\""                                                  >> "$frameworkPath/Dockerfile"
    fi
    if [ $dockerVersionSave ]; then
      echo "COPY --from=iondv-git-framework:$frameworkVer /var/www ."                           >> "$frameworkPath/Dockerfile"
    else
      echo "COPY --from=iondv-git-framework /var/www ."                                        >> "$frameworkPath/Dockerfile"
    fi
    echo "COPY ./init.sh /var/www/init.sh"                                                    >> "$frameworkPath/Dockerfile"
    echo "COPY ./setup.ini /var/www/config/setup.ini"                                         >> "$frameworkPath/Dockerfile"

    echo "COPY --from=iondv-git-$appName:$imageVersion /var/www/applications/ /var/www/applications/"              >> "$frameworkPath/Dockerfile"
    for temp in ${metaDepPairList[@]}; do
      if [ $dockerVersionSave ]; then
        ###echo "COPY --from=iondv-git-$temp /var/www/applications ."                              >> "$frameworkPath/Dockerfile"
        echo "COPY --from=iondv-git-$temp /var/www/applications ./applications"                              >> "$frameworkPath/Dockerfile"
      else
        #echo "COPY --from=iondv-git-${temp%:*} /var/www/applications ."                       >> "$frameworkPath/Dockerfile"
        echo "COPY --from=iondv-git-${temp%:*} /var/www/applications ./applications"                       >> "$frameworkPath/Dockerfile"
      fi
    done

    for temp in ${modulesDepPairList[@]}; do
      if [ $dockerVersionSave ]; then
        echo "COPY --from=iondv-git-$temp /var/www/modules/ ./modules/"                                  >> "$frameworkPath/Dockerfile"
      else
        echo "COPY --from=iondv-git-${temp%:*} /var/www/modules/ ./modules/"                            >> "$frameworkPath/Dockerfile"
      fi
    done
    if [ $postInstScript ] ; then
      cp $postInstScript $frameworkPath/${postInstScript##*/}
      echo "COPY ./${postInstScript##*/} /var/www/${postInstScript##*/}"                      >> "$frameworkPath/Dockerfile"
      ### TODO If script start other script? AND OTHER FILE ???? SHARING FOLDER www into the current one and copy everything into it and run locally in it? Or first collect all files from containers locally and then after utility, copy to docker ???
       # TODO Alternative - copy all files to a container.
      echo "RUN sh /var/www/${postInstScript##*/} && rm -f /var/www/${postInstScript##*/}"                                            >> "$frameworkPath/Dockerfile" # TODO bash?
      # 2del echo "RUN rm -f /var/www/${postInstScript##*/}"                                         >> "$frameworkPath/Dockerfile"
    fi
    #echo "LABEL new=1"                                                                        >> "$frameworkPath/Dockerfile"
    echo "ENV NODE_PATH /var/www"                                                             >> "$frameworkPath/Dockerfile"
    echo "RUN npm install -g node-gyp gulp"                                             >> "$frameworkPath/Dockerfile"
    ### TODO dev only? Because otherwise the docker size is 2.6 gb after removing node-modules ??? or how to reduce? Do not cache when creating docker container ????
    echo "RUN npm install"                                                                    >> "$frameworkPath/Dockerfile" # TODO NPM install gulp
    echo "RUN gulp build"                                                                     >> "$frameworkPath/Dockerfile" # TODO удалить gulp & all devDependences
    # 2del echo "RUN rm -r -f ./node_modules"                                                        >> "$frameworkPath/Dockerfile"
    # 2del echo "RUN npm ci --only=production"                                                       >> "$frameworkPath/Dockerfile" # TODO NPM uninstall dev
    echo "COPY ./.dockerignore /var/www/.dockerignore"                                        >> "$frameworkPath/Dockerfile"

## TODO DO NOT NEED THIS PART? BECAUSE EVERYTHING IS READY FOR DEVELOPMENT - THERE IS A BIG SIZE, BUT THERE IS NO EXTRA OPERATION, HOW LONG DOES IT TAKE?
## TODO IT IS BETTER FOR THE MODULES TO COLLECT DIRECTLY IN THE GIT CONTAINERS OF DOCKERS - and then only copy them.
    echo "FROM node:10 as iondv-$appName"                                                     >>  "$frameworkPath/Dockerfile"
#    echo "FROM node:10-alpine"                                                                 >>  "$frameworkPath/Dockerfile"
#    echo "RUN  apk add --no-cache make g++ \
#         && apk add vips-dev fftw-dev build-base \
#            --update-cache \
#            --repository https://alpine.global.ssl.fastly.net/alpine/edge/community \
#            --repository https://alpine.global.ssl.fastly.net/alpine/edge/main \
#            rm -rf /var/lib/apt/lists/* && rm -fR /var/cache/apk/*"                           >> "$frameworkPath/Dockerfile"
    echo "WORKDIR /var/www"                                                                   >> "$frameworkPath/Dockerfile"
    echo "ENV NODE_PATH /var/www"                                                             >> "$frameworkPath/Dockerfile"
    echo "ENV NODE_ENV production"                                                             >> "$frameworkPath/Dockerfile"
    echo "EXPOSE 8888"                                                                        >> "$frameworkPath/Dockerfile"
    if ! [ $skipTagMode ] ; then
      echo "LABEL version=\"$imageVersion\""                                                 >> "$frameworkPath/Dockerfile"
    fi
    echo "COPY --from=iondv-base-$appName /var/www/ /var/www/"                                >> "$frameworkPath/Dockerfile"
    if [ $startCluster ] ; then
      echo "ENV WORKER_COUNT=$startCluster"                                                   >> "$frameworkPath/Dockerfile"
    fi
    echo "CMD [\"sh\", \"init.sh\"]"                                                          >> "$frameworkPath/Dockerfile"

    #TODO GET app version from package.json
    f_buld_docker_version "$imageName" "$frameworkPath/Dockerfile" "$frameworkPath/." "--check-ignore"
 else
   echo -en "${i_warn}Docker $imageName exists, skip building${i_end}"
 fi
}






##################################
# Git install function           #
##################################
function f_install_git () {

  if ! [ -d $frameworkPath ]; then
    if ! [ $quietMode ] ; then echo "Git: clone IONDV. framework"; fi
    git clone --quiet "$IONDVUrlGitFramework" "$appName"
    if [ $? -ne 0 ]; then echo -en "${i_err} Error cloning $IONDVUrlGitFramework${i_end}"; exit; fi
  else
    cd $frameworkPath
    if ! [ $quietMode ] ; then echo "Git: Stash and update IONDV. framework"; fi
    git stash
    git pull
  fi

  if ! [ -d "$frameworkPath/applications" ]; then
    mkdir "$frameworkPath/applications"
  fi

#  if [ -d "$frameworkPath/applications/$appName" ]; then
#    appVer=`grep -E '\"version\"\s*:\s*\"' $frameworkPath/applications/$appName/package.json | grep -o -E '[0-9\.]+'`
#    git stash
#    git pull
#  else
#    cd "$frameworkPath/applications"
#    if ! [ $quietMode ] ; then echo "Git: clone IONDV. app - $appName from $appGitLink"; fi
#    git clone --quiet "$appGitLink" $appName
#    if [ $? -ne 0 ]; then echo -en "${i_err}Don't clone $appGitLink${i_end}"; exit; fi
#  fi

  if [ -n "$appGitLink" ]; then
    if [ -d "$frameworkPath/applications/$appName" ]; then
      cd "$frameworkPath/applications/$appName"
      appVer=`grep -E '\"version\"\s*:\s*\"' $frameworkPath/applications/$appName/package.json | grep -o -E '[0-9\.]+'`
      git stash
      git pull
      f_switch_branch "$frameworkPath/applications/$appName"
      if [ -z "$(echo $gitBranch | grep -E ".+-[0-9]+" | cat)"  ] ; then
        gitBranch=''
      fi
    else
      cd "$frameworkPath/applications"
      if ! [ $quietMode ] ; then echo "Git: clone IONDV. app - $appName from $appGitLink"; fi
      git clone --quiet "$appGitLink" $appName
      if [ $? -ne 0 ]; then echo -en "${i_err} error cloning $appGitLink${i_end}"; exit; fi
      f_switch_branch "$frameworkPath/applications/$appName"
      if [ -z "$(echo $gitBranch | grep -E ".+-[0-9]+" | cat)"  ] ; then
        gitBranch=''
      fi
    fi
  elif [ -n "$zipPath" ]; then
     unzip -q $zipPath -d "$frameworkPath/applications/"
     unzipName=`ls -1p $frameworkPath/applications | grep '/$' | sed 's/\/$//' | grep $appName` # If zip from github - it have branch on folder name
     if [ -z $unzipName ]; then echo "$zipPath no folder with this name - $appName. Exit"; exit; fi
     echo "Unpack name $unzipName, appName: $appName"
     if [ "$unzipName" != "$appName" ]; then
       echo -en "${i_warn}Folder $unzipName not equal to $appName. Does it include branch name? Rename to $appName${i_end}"
       mv "$frameworkPath/applications/$unzipName" "$frameworkPath/applications/$appName"
     fi
     cd "$frameworkPath/applications/$appName"
     if [ -n "$(git status | grep -e "^On branch*" | grep -E ".+-[0-9]+" | cat)" ] ; then
       gitBranch=$(git status | grep -e "^On branch*" | cat)
       gitBranch=${gitBranch##On branch }
       echo "building branch $gitBranch"
     fi
  elif [ -n "$folderPath" ]; then
     cp -r $folderPath "$frameworkPath/applications/$appName"
     cd "$frameworkPath/applications/$appName"
     if [ $? -ne 0 ] ; then echo "Error copying source folder. Exiting." ; exit ; fi
     if [ -n "$(git status | grep -e "^On branch*" | grep -E ".+-[0-9]+" | cat)" ] ; then
       gitBranch=$(git status | grep -e "^On branch*" | cat)
       gitBranch=${gitBranch##On branch }
       echo "building branch $gitBranch"
     fi
  else
    echo -en "${i_err} App source is not found. Exit${i_end}"
    exit
  fi

  if [ $appGetVersion ] ; then
    cd "$frameworkPath/applications/$appName"
    git checkout "tags/$appGetVersion"
    appVer=`grep -E '\"version\"\s*:\s*\"' $frameworkPath/applications/$appName/package.json | grep -o -E '[0-9\.]+'`
    if [[ $appGetVersion != $appVer ]] ; then
      echo -en "${i_warn}App version is not valid. Required is $appGetVersion, current is $appVer.${i_end}"
      exit
    fi
  else
    appVer=`grep -E '\"version\"\s*:\s*\"' $frameworkPath/applications/$appName/package.json | grep -o -E '[0-9\.]+'`
  fi
  if ! [ $quietMode ] ; then echo "Preparing app version: $appVer"; fi

  # Change app name and namespace
  if [ $newAppName ] ; then
    cd $startDir
    $scriptPath/change-namespace.sh $quietMode "$frameworkPath/applications/$appName" $prevAppName $newAppName
  fi

  # package.json dependencies
  # engines - iondv framework version

  if ! [ $skipTagMode ] ; then f_get_framework_ver $frameworkPath/applications/$appName/package.json; fi
  if [ -n "$frameworkVer" ]; then
    if ! [ $quietMode ] ; then echo "Use ion engine: $frameworkVer"; fi
  #  cd "$frameworkPath"
  #  git checkout tags/$frameworkVer
    f_switch_branch $frameworkPath "tags/$frameworkVer"
  else
    f_switch_branch $frameworkPath
  fi #<------------------- IS IT STILL NEEDED?

  # ionMetaDependencies
  f_get_metadep_ver $frameworkPath/applications/$appName/package.json
  for temp in ${metaDepPairList[@]}; do
    if ! [ $quietMode ] ; then echo "Install ext-app: ${temp%:*}"; fi
    if ! [ -d "$frameworkPath/applications/${temp%:*}" ]; then
      cd $frameworkPath/applications
      git clone --quiet "$IONDVUrlGitExtApp/${temp%:*}.git"
      if [ $? -ne 0 ]; then echo -en "${i_err} error cloning $IONDVUrlGitExtApp/${temp%:*}.git${i_end}"; exit; fi
    else
      cd "$frameworkPath/applications/${temp%:*}"
      git stash
      git pull
    fi
    if ! [ $skipTagMode ] ; then
      cd "$frameworkPath/applications/${temp%:*}"
      f_switch_branch "$frameworkPath/applications/${temp%:*}" "tags/${temp##*:}"
    else
      f_switch_branch "$frameworkPath/applications/${temp%:*}"
    fi
  done

  if ! [ -d $frameworkPath/modules ]; then
    mkdir $frameworkPath/modules
  fi

  # ionModulesDependencies
  f_get_modulesdep_ver $frameworkPath/applications/$appName/package.json
  for temp in ${modulesDepPairList[@]}; do
    if ! [ $quietMode ] ; then echo "Install module: ${temp%:*}"; fi
    if ! [ -d "$frameworkPath/modules/${temp%:*}" ]; then
      cd $frameworkPath/modules
      git clone --quiet "$IONDVUrlGitModules/${temp%:*}.git"
      if [ $? -ne 0 ]; then echo -en "${i_err} error cloning $IONDVUrlGitModules/${temp%:*}.git${i_end}"; exit; fi
    else
      cd "$frameworkPath/modules/${temp%:*}"
      git stash
      git pull
    fi
    if ! [ $skipTagMode ] ; then
      cd "$frameworkPath/modules/${temp%:*}"
      f_switch_branch "$frameworkPath/modules/${temp%:*}" "tags/${temp##*:}"
    else
      f_switch_branch "$frameworkPath/modules/${temp%:*}"
    fi
  done

  if ! [ $quietMode ] ; then echo "Build IONDV application: $appName"; fi
  cd $frameworkPath
  export NODE_PATH=$frameworkPath

  f_create_setup_ini "/config"
  f_create_init_sh

  cd $frameworkPath

 if [ $dockerUse ]; then
    nodeVersion=`node --version | grep -Po "^v\d+" |  grep -Po "\d+"`
    echo "FROM node:$nodeVersion" > "$frameworkPath/Dockerfile"
    echo "WORKDIR /var/www" >> "$frameworkPath/Dockerfile"
    echo "EXPOSE 8888" >> "$frameworkPath/Dockerfile"
    echo "ENV NODE_PATH /var/www" >> "$frameworkPath/Dockerfile"
    echo "ENV NODE_ENV production" >> "$frameworkPath/Dockerfile"
    echo "COPY . ." >> "$frameworkPath/Dockerfile"
    if [ $startCluster ] ; then echo "ENV WORKER_COUNT $startCluster" >> "$frameworkPath/Dockerfile"; fi
    echo "CMD [\"bash\", \"init.sh\"]" >> "$frameworkPath/Dockerfile"
  fi

  if [ $postInstScript ] ; then
    if ! [ $quietMode ] ; then echo -en "${i_info}Running postinstall script $postInstScript, before building the app${i_end}"; fi
    $postInstScript
  fi

  #npm -no-package-lock install gulp@"^4.0.0" gulp-clean-css@"~4.0.0" gulp-jsmin@"~0.1.5" gulp-less@"~4.0.1" gulp-rename@"~1.4.0"
  npm install

  gulp build
  if [ $? -ne 0 ]; then
    echo -en "${i_err}Build app error. Exit${i_end}"
    exit
  fi

#  rm -r -f ./node_modules

#  if ! [ $quietMode ] ; then echo 'Install npm production'; fi
#  npm ci --only=production
  echo "Test user. Login: demo, password: ion-demo"
  if [ $dockerUse ]; then
    f_stop_docker
    f_dockerignore
#    nodeVersion=`node --version | grep -Po "^v\d+" |  grep -Po "\d+"`
#    echo "FROM node:$nodeVersion" > "$frameworkPath/Dockerfile"
#    echo "WORKDIR /var/www" >> "$frameworkPath/Dockerfile"
#    echo "EXPOSE 8888" >> "$frameworkPath/Dockerfile"
#    echo "ENV NODE_PATH /var/www" >> "$frameworkPath/Dockerfile"
#    echo "COPY . ." >> "$frameworkPath/Dockerfile"
#    if [ $startCluster ] ; then echo "ENV WORKER_COUNT $startCluster" >> "$frameworkPath/Dockerfile"; fi
#    echo "CMD [\"bash\", \"init.sh\"]" >> "$frameworkPath/Dockerfile"
    f_buld_docker_version "$imageName" "$frameworkPath/Dockerfile" "$frameworkPath/." "--check-ignore"
    if ! [ $skipRun ]; then f_start_docker; fi
  else
    # TODO Remove database?
    if ! [ $skipRun ]; then bash ./init.sh; fi
  fi
}


########################
# Docker operations
##########################

function f_stop_docker() {
  echo -en "${i_warn}Will stop container and remove $dockerName, remove docker image: $imageName${i_end}"
#  echo -en "${i_warn}And it will drop db: $dbName${i_end}"
  if [ $yesToAll ] ; then
    choice="y"
  else
    read -p "Continue (y/n)?" choice
  fi
  case "$choice" in
    y|Y )
      if docker ps | grep -o $dockerName ; then
        echo -n "  Stop container:           ";  docker stop $dockerName;
        echo -n "  Remove container:         ";  docker rm $dockerName
      elif docker ps -a | grep -o $dockerName ; then
        echo -n "  Remove container:         ";  docker rm $dockerName
      else echo "  There is no container $dockerName to stop";
      fi
      if docker image list | grep -o ${imageName%%:*} ; then
        echo -n "  Remove image:           ";  docker rmi $imageName
      else echo "  There is no image $imageName to remove";
      fi
#      echo -n "  Remove db: $dbName "; docker exec -it $mongoLink mongo $dbName --quiet --eval "db.dropDatabase();"
     ;;
    n|N );;
    * ) echo "invalid";;
  esac
}

function f_start_docker() {
  docker ps | grep "0.0.0.0:8888->8888/tcp"
  if [ $? -eq 0 ]; then echo -en "${i_warn}Port 8888 is busy, app won't start. Please exec: docker restart $dockerName${i_end}"; fi
  if [ $mongoLink ] ; then
    if ! [ $quietMode ] ; then echo "Running docker container: $dockerName from $imageName, linked to $mongoLink"; fi
    docker run -d -p 8888:8888 --name $dockerName --link $mongoLink $imageName
  else   # TODO docker needs some kind of port forwarding on host. And the parameter - run or not.
    if ! [ $quietMode ] ; then echo "Running docker container: $dockerName from $imageName"; fi
    docker run -d -p 8888:8888 --name $dockerName $imageName
  fi
  echo -en "${i_info}Test user. Login: demo, password: ion-demo${i_end}"
  sleep 60
  if ! [ $quietMode ] ; then docker logs $dockerName; fi
  curl localhost:8888 # TODO Check result - redirect to default from setup
  echo
#  if [ $yesToAll ] ; then
#    echo "Save docker container to file"
#    choice="y"
#  else
#    read -p "\nSave docker container to file $startDir/$dockerName.docker-image.tar (y/n)?" choice
#  fi
#  case "$choice" in
#    y|Y )
#      docker save $imageName -o $startDir/$dockerName.docker-image.tar
#      echo -en "${i_info}Save $startDir/$dockerName.docker-image.tar${i_end}"
#      ;;
#    n|N );;
#    * ) echo "invalid";;
#  esac
}

##################################
# Docker install function        #
##################################
function f_install_docker() {
  echo -en "${i_info}Create docker image: $imageName and run docker name:  $dockerName${i_end}"
  f_stop_docker

  if ! [ -d $frameworkPath ]; then mkdir $frameworkPath; fi
  f_dockerignore
  f_build_docker
  if ! [ $skipRun ]; then f_start_docker; fi
}

##################################
# START SCRIPT                   #
##################################

# Process param and path
while [ -n "$1" ]
do
case "$1" in
  -d) dockerUse=1; paramInfo="$paramInfo\n  - found the docker build option";;
  -c) startCluster=$2; paramInfo="$paramInfo\n  - found the cluster option: $startCluster"
  shift ;;
  -r) removeAppFolder=1; paramInfo="$paramInfo\n  - found the remove current app folder option";;
  -k) skipCheck=1; paramInfo="$paramInfo\n  - found the skip check option";;
  -i) importData=1; paramInfo="$paramInfo\n  - found the import data option";;
  -a) importAcl=1; paramInfo="$paramInfo\n  - found the import acl option";;
  -y) yesToAll=1; paramInfo="$paramInfo\n  - found yes to all option";;
  -q) quietMode=1; paramInfo="$paramInfo\n  - found the quiet data option";;
  -h) skipTagMode=1; paramInfo="$paramInfo\n  - found the skip tag checkout option";;
  -v) dockerVersionSave=1; paramInfo="$paramInfo\n  - found the save provisional docker image as template version option";;
  -x) skipRun=1; paramInfo="$paramInfo\n  - found the exit after build, without start app option";;
  -l) mongoLink="$2"; paramInfo="$paramInfo\n  - found the docker mongo link option: $mongoLink"
  shift ;;
  -m) mongodbUri="$2"; paramInfo="$paramInfo\n  - found the mongodb option: $mongodbUri"
  shift ;;
  -t) buildType="$2"; paramInfo="$paramInfo\n  - found the type of build method option: $buildType"
  shift ;;
  -n) newAppName="$2"; paramInfo="$paramInfo\n  - found the new app name option: $newAppName"
  shift ;;
  -p) installDir="$2"; paramInfo="$paramInfo\n  - found the path option: $installDir"
  shift ;;
  -s) postInstScript="$2"; paramInfo="$paramInfo\n  - found the script option: $postInstScript"
  shift ;;
  -g) fallbackBranch="$2"; paramInfo="$paramInfo\n  - found the fallback branch option: $fallbackBranch"
  shift ;;
  *)  if [[ ${1:0:1} == "-" ]] ; then 
        echo "$1 is not an option" 
        shift
      else 
        appName="$1"
      fi;;
  esac
shift
done
if ! [ $appName ] ; then 
  echo -en "${i_err}Application name or git url isn't set${i_end}"
  exit
fi

# Default value
if ! [ $mongodbUri ] ; then  mongodbUri="localhost:27017"; fi
if ! [ $IONDVUrlGitFramework ] ; then IONDVUrlGitFramework=https://github.com/iondv/framework.git; fi
if ! [ $IONDVUrlGitModules ] ; then IONDVUrlGitModules=https://github.com/iondv; fi
if ! [ $IONDVUrlGitApp ] ; then IONDVUrlGitApp=https://github.com/iondv; fi
if ! [ $IONDVUrlGitExtApp ] ; then IONDVUrlGitExtApp=https://github.com/iondv; fi

if echo $appName | grep -Po "^http" > /dev/null ; then
  appGitLink=$appName
  appName=`echo $appName | grep -Po "[\-\w]+\.git" | sed 's/.git//'`
  if [ -z "$appName" ] ; then appName=${appGitLink##http*//*/} ; fi
elif echo $appName | grep -Po "^\/{1}|^\.{1,2}\/{1}" > /dev/null ; then # Check folder or file
  echo "Path $appName"
  if echo $appName | grep -Po "\.zip\$" > /dev/null ; then
    if ! [ -f $appName ]; then echo "Zip file with app is not found. Check path $appName"; exit; fi
    zipPath=$appName
    temp=${appName##*/}
    appName=${temp%.zip*}
  else
    echo "FOLDER $appName"
     if ! [ -d $appName ]; then echo -en "${i_err}Folder with app is not found. Check path $appName${i_end}"; exit; fi
     folderPath=${appName}
     appName=${appName##*/}
  fi
elif [[ $appName =~ "@" ]] ; then
  appGetVersion=${appName##*@}
  appName=${appName%@*}
  appGitLink=$IONDVUrlGitApp/$appName.git
else
  appGitLink=$IONDVUrlGitApp/$appName.git
fi
if [ $appGitLink ]; then
  http_code=`curl -L -s -k -w %{http_code} -o /dev/null $appGitLink`
  if [[ $http_code != '200' ]]; then echo -en "${i_err}Check failed url $appGitLink, code $http_code. Exit${i_end}"; exit;
  else echo "Source. Type Git. URL $appGitLink"; fi
  if (echo $appGitLink | grep -e '/tree/' > /dev/null)
    then
      gitBranch=${appGitLink#*/tree/}
      appGitLink=${appGitLink%%/tree/*}
      echo "building branch $gitBranch from $appGitLink"
      appName=${appGitLink#*//*/*/}
      frameworkPath="$(pwd)/${appName}"
  fi
fi

if [ $newAppName ] ; then
  if ! [ $appGitLink ] ; then appGitLink=$IONDVUrlGitApp/$appName.git ; fi
  prevAppName=$appName
  appName=$newAppName
fi
# TODO from zip archive or from folder - add check by stratum and by extension

dbName=$appName
dockerName="$appName"
if [ $appGetVersion ] ; then imageVersion=$appGetVersion; else imageVersion="latest";  fi
imageName="iondv-$appName:$imageVersion"

if ! [ $quietMode ] ; then
  echo -e "Build parameters$paramInfo";
  echo "  - framework URL: $IONDVUrlGitFramework"
  echo "  - module base URL: $IONDVUrlGitModules"
  echo "  - app base URL: $IONDVUrlGitApp"
  echo "  - extApp base URL: $IONDVUrlGitExtApp"
  if [ $appGitLink ]; then echo "  - app's source type: git"; echo "  - app git link: $appGitLink"; fi
  if [ $zipPath ]; then echo "  - app's source type: zip"; echo "  - app path: $zipPath"; fi
  if [ $folderPath ]; then echo "  - app's source type: folder"; echo "  - app path: $folderPath"; fi
  if [ $prevAppName ] ; then
    echo "  - changed namespace: $prevAppName"
    echo "  - new app name and namespace: $appName"
  else 
    echo "  - app name: $appName"
  fi
  if [ $appGetVersion ] ; then echo "  - app version: $appGetVersion"; fi
fi

if [ $mongoLink ] ; then
  mongodbUri="$mongoLink:27017"
  if ! [ $quietMode ] ; then echo "  - set Mongo uri to $mongodbUri"; fi
fi

# Check
if ! [ $skipCheck ] ; then
  if [[ $buildType != "docker" ]] ; then
    f_check_git
    f_check_node
    f_check_npm_dep
	# handy for several building tasks
	apt-get install -y build-essential
	#apt-get install -y g++
  fi
  f_check_mongo
  if ! [ $quietMode ] ; then echo 'Check success.'; fi
fi

# Set path
if ! [ $installDir ] ; then
  echo 'Use current dir for workspace'
  installDir=$startDir
fi

frameworkPath=$installDir/$appName
if [ "$installDir/" == $frameworkPath ] ; then
  echo "Error: framework path can't be equal to the install directory. Exiting."
  exit 1
fi

if [ $removeAppFolder ] ; then
  echo -en "${i_warn}Remove $frameworkPath${i_end}"
  rm -r -f $frameworkPath
fi

if ! [ $quietMode ] ; then
  echo "Insalling app:          $appName"
  echo "  - workspace dir:        $installDir"
  echo "  - framework path:       $frameworkPath"
  if [ $postInstScript ] ; then echo "  - post-install script:   $postInstScript"; fi
fi
cd $installDir

# Build
if [ -z "$buildType" ]; then
  echo "Build method isn't set. Use docker by default"
  f_install_docker
else
  case "$buildType" in
    'docker') echo "Use docker build method"
        f_install_docker;;
    'git') echo "Use git build method"
        f_install_git;;
    *)  echo "Wrong build method: $buildType. Use default: docker"
        f_install_docker;;
  esac
fi

cd $startDir
